#include <string>
#include <vector>

#include <google/protobuf/compiler/code_generator.h>
#include <google/protobuf/compiler/plugin.h>
#include <google/protobuf/compiler/plugin.pb.h>
#include <google/protobuf/descriptor.h>

std::string& ReplaceString(std::string& source, const std::string& replace_what,
                           const std::string& replace_with_what) {
  std::string::size_type pos = 0;
  while (true) {
    pos = source.find(replace_what, pos);
    if (pos == std::string::npos) break;
    source.replace(pos, replace_what.size(), replace_with_what);
    pos += replace_with_what.size();
  }

  return source;
}

std::vector<std::string> SplitToVec(const std::string& source,
                                    const std::string& sep, bool clear = true) {
  std::vector<std::string> result;
  if (source.empty() || sep.empty()) return result;

  size_t pos_end, pos_start = 0;
  do {
    pos_end = source.find(sep, pos_start);
    if (pos_end == std::string::npos) pos_end = source.length();

    const std::string& sub_str = source.substr(pos_start, pos_end - pos_start);
    if (!(clear && sub_str.empty())) {
      result.emplace_back(sub_str);
    }

    pos_start = pos_end + sep.size();
  } while (pos_end < source.length());

  return result;
}

class AimRTCodeGenerator final
    : public google::protobuf::compiler::CodeGenerator {
 public:
  AimRTCodeGenerator() = default;
  ~AimRTCodeGenerator() override = default;

  uint64_t GetSupportedFeatures() const override {
    return FEATURE_PROTO3_OPTIONAL;
  }

  constexpr static std::string_view t_hfile_one_service_func = R"str(
  virtual aimrt::co::Task<aimrt::rpc::Status> {{rpc_func_name}}(
      aimrt::rpc::ContextRef ctx_ref,
      const {{rpc_req_name}}& req,
      {{rpc_rsp_name}}& rsp);)str";

  constexpr static std::string_view t_hfile_one_service_class = R"str(
class {{service_name}} : public aimrt::rpc::ServiceBase {
 public:
  {{service_name}}();
  ~{{service_name}}() override = default;
{{hfile_service_func}}
};)str";

  constexpr static std::string_view t_hfile_one_service_proxy_func = R"str(
  aimrt::co::Task<aimrt::rpc::Status> {{rpc_func_name}}(
      aimrt::rpc::ContextRef ctx_ref,
      const {{rpc_req_name}}& req,
      {{rpc_rsp_name}}& rsp);

  aimrt::co::Task<aimrt::rpc::Status> {{rpc_func_name}}(
      const {{rpc_req_name}}& req,
      {{rpc_rsp_name}}& rsp) {
    static constexpr aimrt::rpc::ContextRef ctx_ref{};
    return {{rpc_func_name}}(ctx_ref, req, rsp);
  })str";

  constexpr static std::string_view t_hfile_one_service_proxy_class = R"str(
class {{service_name}}Proxy : public aimrt::rpc::ProxyBase {
 public:
  explicit {{service_name}}Proxy(aimrt::rpc::RpcHandleRef rpc_handle_ref)
      : aimrt::rpc::ProxyBase(rpc_handle_ref) {}
  ~{{service_name}}Proxy() = default;

  static bool RegisterClientFunc(aimrt::rpc::RpcHandleRef rpc_handle_ref);
{{hfile_service_proxy_func}}
};)str";

  constexpr static std::string_view t_hfile = R"str(/**
 * @file {{file_name}}.aimrt_rpc.pb.h
 * @brief This file was generated by protoc-gen-aimrt_rpc which is a self-defined pb compiler plugin, do not edit it!!!
 */
#pragma once

#include "aimrt_module_cpp_interface/rpc/rpc_handle.h"
#include "aimrt_module_cpp_interface/rpc/rpc_status.h"

#include "aimrt_module_cpp_interface/co/task.h"

#include "{{file_name}}.pb.h"

{{namespace_begin}}
{{hfile_service_class}}
{{hfile_service_proxy_class}}
{{namespace_end}}
)str";

  constexpr static std::string_view t_ccfile_one_service_register_func = R"str(
  {
    aimrt::Function<aimrt_function_service_func_ops_t> callback(
        [this](const aimrt_rpc_context_base_t* ctx, const void* req, void* rsp, aimrt_function_base_t* callback) {
          static const aimrt::rpc::RpcHandle h =
              [this](aimrt::rpc::ContextRef ctx_ref, const void* req_ptr, void* rsp_ptr)
              -> aimrt::co::Task<aimrt::rpc::Status> {
            return {{rpc_func_name}}(
                ctx_ref,
                *static_cast<const {{rpc_req_name}}*>(req_ptr),
                *static_cast<{{rpc_rsp_name}}*>(rsp_ptr));
          };

          aimrt::co::StartDetached(
              filter_mgr_.InvokeRpc(h, aimrt::rpc::ContextRef(ctx), req, rsp),
              [callback](aimrt::rpc::Status status) {
                (aimrt::Function<aimrt_function_service_callback_ops_t>(callback))(status.Code());
              });
        });
    RegisterServiceFunc(
        "pb:/{{package_name}}.{{service_name}}/{{rpc_func_name}}",
        nullptr,
        aimrt::GetProtobufMessageTypeSupport<{{rpc_req_name}}>(),
        aimrt::GetProtobufMessageTypeSupport<{{rpc_rsp_name}}>(),
        callback.NativeHandle());
  })str";

  constexpr static std::string_view t_ccfile_one_service_func = R"str(
aimrt::co::Task<aimrt::rpc::Status> {{service_name}}::{{rpc_func_name}}(
    aimrt::rpc::ContextRef ctx_ref,
    const {{rpc_req_name}}& req,
    {{rpc_rsp_name}}& rsp) {
  co_return aimrt::rpc::Status(aimrt::rpc::Status::RetCode::SVR_NOT_IMPLEMENTED);
})str";

  constexpr static std::string_view t_ccfile_one_service_class = R"str(
{{service_name}}::{{service_name}}() {
{{ccfile_service_register_func}}
}
{{ccfile_service_func}}
)str";

  constexpr static std::string_view t_ccfile_one_service_proxy_register_func = R"str(
  if (!(rpc_handle_ref.RegisterClientFunc(
          "pb:/{{package_name}}.{{service_name}}/{{rpc_func_name}}",
          nullptr,
          aimrt::GetProtobufMessageTypeSupport<{{rpc_req_name}}>(),
          aimrt::GetProtobufMessageTypeSupport<{{rpc_rsp_name}}>())))
    return false;)str";

  constexpr static std::string_view t_ccfile_one_service_proxy_func = R"str(
aimrt::co::Task<aimrt::rpc::Status> {{service_name}}Proxy::{{rpc_func_name}}(
    aimrt::rpc::ContextRef ctx_ref,
    const {{rpc_req_name}}& req,
    {{rpc_rsp_name}}& rsp) {
  static const aimrt::rpc::RpcHandle h =
      [rpc_handle_ref{rpc_handle_ref_}](aimrt::rpc::ContextRef ctx_ref, const void* req_ptr, void* rsp_ptr)
      -> aimrt::co::Task<aimrt::rpc::Status> {
    co_return co_await aimrt::co::AsyncWrapper<aimrt::rpc::Status>(
        [rpc_handle_ref, ctx_ref, req_ptr, rsp_ptr](
            aimrt::Function<void(aimrt::rpc::Status)>&& call_back) {
          rpc_handle_ref.Invoke(
              "pb:/{{package_name}}.{{service_name}}/{{rpc_func_name}}",
              ctx_ref, req_ptr, rsp_ptr,
              [call_back{std::move(call_back)}](uint32_t code) {
                call_back(aimrt::rpc::Status(code));
              });
        });
  };

  if (ctx_ref) {
    if (ctx_ref.GetSerializationType().empty()) ctx_ref.SetSerializationType("pb");
    co_return co_await filter_mgr_.InvokeRpc(h, ctx_ref, static_cast<const void*>(&req), static_cast<void*>(&rsp));
  }

  auto ctx_ptr = rpc_handle_ref_.NewContextSharedPtr();
  ctx_ref = aimrt::rpc::ContextRef(ctx_ptr);
  ctx_ref.SetSerializationType("pb");
  co_return co_await filter_mgr_.InvokeRpc(h, ctx_ref, static_cast<const void*>(&req), static_cast<void*>(&rsp));
})str";

  constexpr static std::string_view t_ccfile_one_service_proxy_class = R"str(
bool {{service_name}}Proxy::RegisterClientFunc(aimrt::rpc::RpcHandleRef rpc_handle_ref) {
{{ccfile_service_proxy_register_func}}
  return true;
}
{{ccfile_service_proxy_func}}
)str";

  constexpr static std::string_view t_ccfile = R"str(/**
 * @file {{file_name}}.aimrt_rpc.pb.cc
 * @brief This file was generated by protoc-gen-aimrt_rpc which is a self-defined pb compiler plugin, do not edit it!!!
 */

#include "{{file_name}}.aimrt_rpc.pb.h"

#include "aimrt_module_cpp_interface/co/async_wrapper.h"
#include "aimrt_module_cpp_interface/co/start_detached.h"
#include "aimrt_module_protobuf_interface/util/protobuf_type_support.h"

#include <google/protobuf/stubs/stringpiece.h>
#include <google/protobuf/util/json_util.h>

{{namespace_begin}}
{{ccfile_service_class}}
{{ccfile_service_proxy_class}}
{{namespace_end}}
)str";

  static std::string ProtoFileBaseName(const std::string& full_name) {
    return full_name.substr(0, full_name.rfind("."));
  }

  static std::string GenNamespaceStr(const std::string& ns) {
    std::string result = ns;
    return ReplaceString(result, ".", "::");
  }

  static std::string GenNamespaceBeginStr(const std::string& ns) {
    const std::vector<std::string>& namespace_vec = SplitToVec(ns, ".");
    std::string result;
    for (const auto& itr : namespace_vec) {
      result += ("namespace " + itr + " {\n");
    }
    return result;
  }

  static std::string GenNamespaceEndStr(const std::string& ns) {
    const std::vector<std::string>& namespace_vec = SplitToVec(ns, ".");
    std::string result;
    for (const auto& itr : namespace_vec) {
      result += ("}  // namespace " + itr + "\n");
    }
    return result;
  }

  static void WriteToFile(google::protobuf::compiler::GeneratorContext* context,
                          const std::string& file_name,
                          const std::string& file_context) {
    std::unique_ptr<google::protobuf::io::ZeroCopyOutputStream> output(context->Open(file_name));
    google::protobuf::io::CodedOutputStream coded_out(output.get());
    coded_out.WriteRaw(file_context.data(), file_context.size());
  }

  bool Generate(const google::protobuf::FileDescriptor* file,
                const std::string& parameter,
                google::protobuf::compiler::GeneratorContext* context,
                std::string* error) const override {
    const std::string& file_name = ProtoFileBaseName(file->name());
    const std::string& package_name = file->package();
    const std::string& namespace_begin = GenNamespaceBeginStr(file->package());
    const std::string& namespace_end = GenNamespaceEndStr(file->package());

    // file
    std::string hfile_service_class;
    std::string hfile_service_proxy_class;

    std::string ccfile_service_class;
    std::string ccfile_service_proxy_class;

    for (int ii = 0; ii < file->service_count(); ++ii) {
      // service
      auto service = file->service(ii);

      if (ii != 0) {
        hfile_service_class += "\n";
        hfile_service_proxy_class += "\n";
        ccfile_service_class += "\n";
        ccfile_service_proxy_class += "\n";
      }

      const std::string& service_name = service->name();

      std::string hfile_service_func;
      std::string hfile_service_proxy_func;

      std::string ccfile_service_register_func;
      std::string ccfile_service_func;
      std::string ccfile_service_proxy_register_func;
      std::string ccfile_service_proxy_func;

      for (int jj = 0; jj < service->method_count(); ++jj) {
        // method
        auto method = service->method(jj);

        if (jj != 0) {
          hfile_service_func += "\n";
          hfile_service_proxy_func += "\n";
          ccfile_service_register_func += "\n";
          ccfile_service_func += "\n";
          ccfile_service_proxy_register_func += "\n";
          ccfile_service_proxy_func += "\n";
        }

        const std::string& rpc_func_name = method->name();
        const std::string& rpc_req_name = "::" + GenNamespaceStr(method->input_type()->full_name());
        const std::string& rpc_rsp_name = "::" + GenNamespaceStr(method->output_type()->full_name());

        std::string hfile_one_service_func = std::string(t_hfile_one_service_func);
        ReplaceString(hfile_one_service_func, "{{rpc_req_name}}", rpc_req_name);
        ReplaceString(hfile_one_service_func, "{{rpc_rsp_name}}", rpc_rsp_name);
        ReplaceString(hfile_one_service_func, "{{rpc_func_name}}", rpc_func_name);
        hfile_service_func += hfile_one_service_func;

        std::string hfile_one_service_proxy_func = std::string(t_hfile_one_service_proxy_func);
        ReplaceString(hfile_one_service_proxy_func, "{{rpc_req_name}}", rpc_req_name);
        ReplaceString(hfile_one_service_proxy_func, "{{rpc_rsp_name}}", rpc_rsp_name);
        ReplaceString(hfile_one_service_proxy_func, "{{rpc_func_name}}", rpc_func_name);
        hfile_service_proxy_func += hfile_one_service_proxy_func;

        std::string ccfile_one_service_register_func = std::string(t_ccfile_one_service_register_func);
        ReplaceString(ccfile_one_service_register_func, "{{rpc_req_name}}", rpc_req_name);
        ReplaceString(ccfile_one_service_register_func, "{{rpc_rsp_name}}", rpc_rsp_name);
        ReplaceString(ccfile_one_service_register_func, "{{rpc_func_name}}", rpc_func_name);
        ccfile_service_register_func += ccfile_one_service_register_func;

        std::string ccfile_one_service_func = std::string(t_ccfile_one_service_func);
        ReplaceString(ccfile_one_service_func, "{{rpc_req_name}}", rpc_req_name);
        ReplaceString(ccfile_one_service_func, "{{rpc_rsp_name}}", rpc_rsp_name);
        ReplaceString(ccfile_one_service_func, "{{rpc_func_name}}", rpc_func_name);
        ccfile_service_func += ccfile_one_service_func;

        std::string ccfile_one_service_proxy_register_func = std::string(t_ccfile_one_service_proxy_register_func);
        ReplaceString(ccfile_one_service_proxy_register_func, "{{rpc_req_name}}", rpc_req_name);
        ReplaceString(ccfile_one_service_proxy_register_func, "{{rpc_rsp_name}}", rpc_rsp_name);
        ReplaceString(ccfile_one_service_proxy_register_func, "{{rpc_func_name}}", rpc_func_name);
        ccfile_service_proxy_register_func += ccfile_one_service_proxy_register_func;

        std::string ccfile_one_service_proxy_func = std::string(t_ccfile_one_service_proxy_func);
        ReplaceString(ccfile_one_service_proxy_func, "{{rpc_req_name}}", rpc_req_name);
        ReplaceString(ccfile_one_service_proxy_func, "{{rpc_rsp_name}}", rpc_rsp_name);
        ReplaceString(ccfile_one_service_proxy_func, "{{rpc_func_name}}", rpc_func_name);
        ccfile_service_proxy_func += ccfile_one_service_proxy_func;
      }

      std::string hfile_one_service_class = std::string(t_hfile_one_service_class);
      ReplaceString(hfile_one_service_class, "{{hfile_service_func}}", hfile_service_func);
      ReplaceString(hfile_one_service_class, "{{service_name}}", service_name);
      hfile_service_class += hfile_one_service_class;

      std::string hfile_one_service_proxy_class = std::string(t_hfile_one_service_proxy_class);
      ReplaceString(hfile_one_service_proxy_class, "{{hfile_service_proxy_func}}", hfile_service_proxy_func);
      ReplaceString(hfile_one_service_proxy_class, "{{service_name}}", service_name);
      hfile_service_proxy_class += hfile_one_service_proxy_class;

      std::string ccfile_one_service_class = std::string(t_ccfile_one_service_class);
      ReplaceString(ccfile_one_service_class, "{{ccfile_service_register_func}}", ccfile_service_register_func);
      ReplaceString(ccfile_one_service_class, "{{ccfile_service_func}}", ccfile_service_func);
      ReplaceString(ccfile_one_service_class, "{{service_name}}", service_name);
      ccfile_service_class += ccfile_one_service_class;

      std::string ccfile_one_service_proxy_class = std::string(t_ccfile_one_service_proxy_class);
      ReplaceString(ccfile_one_service_proxy_class, "{{ccfile_service_proxy_register_func}}", ccfile_service_proxy_register_func);
      ReplaceString(ccfile_one_service_proxy_class, "{{ccfile_service_proxy_func}}", ccfile_service_proxy_func);
      ReplaceString(ccfile_one_service_proxy_class, "{{service_name}}", service_name);
      ccfile_service_proxy_class += ccfile_one_service_proxy_class;
    }

    // hfile
    std::string hfile = std::string(t_hfile);
    ReplaceString(hfile, "{{hfile_service_class}}", hfile_service_class);
    ReplaceString(hfile, "{{hfile_service_proxy_class}}", hfile_service_proxy_class);
    ReplaceString(hfile, "{{file_name}}", file_name);
    ReplaceString(hfile, "{{namespace_begin}}", namespace_begin);
    ReplaceString(hfile, "{{namespace_end}}", namespace_end);
    ReplaceString(hfile, "{{package_name}}", package_name);
    WriteToFile(context, file_name + ".aimrt_rpc.pb.h", hfile);

    // ccfile
    std::string ccfile = std::string(t_ccfile);
    ReplaceString(ccfile, "{{ccfile_service_class}}", ccfile_service_class);
    ReplaceString(ccfile, "{{ccfile_service_proxy_class}}", ccfile_service_proxy_class);
    ReplaceString(ccfile, "{{file_name}}", file_name);
    ReplaceString(ccfile, "{{namespace_begin}}", namespace_begin);
    ReplaceString(ccfile, "{{namespace_end}}", namespace_end);
    ReplaceString(ccfile, "{{package_name}}", package_name);
    WriteToFile(context, file_name + ".aimrt_rpc.pb.cc", ccfile);

    return true;
  }
};

int main(int argc, char* argv[]) {
  AimRTCodeGenerator generator;
  return google::protobuf::compiler::PluginMain(argc, argv, &generator);
}
